# Javascript/ 자료형, 백틱, for문, while문, 배열

## 자바스크립트의 모든 자료형은 참조변수입니다.
참조변수란 한마디로 뭐냐? 값이 직접 저장되는 게 아니고, 
원본 값은 heap메모리 영역에 있고, stack 메모리에다가 주소값이 저장됨. 
- 스택메모리
선입선출(FIFO)이 아니라 후입선출(LIFO) - 의외지?
자바의 구조에선 원시자료형과 주소값 데이터밖에 없음.
- 힙메모리
=> 자바가 가비지 컬렉터하는 메모리
객체와 배열의 데이터만 주로 반영됨.

자바스크립트는 모두 힙메모리에 저장됨.

## 독특한 자료형 - null과 undefined
(1) null
- 자바스크립트의 null - 엄연한 자료형(doesn’t exist YET)
- but, 자바 의 null - 객체가 구현되지 않음(초기화용도)
- sql의 null - 데이터가 존재하지 않음. 

```
let a; --> a : undefined 
```


(2) undefined
시스템(컴파일러)이 출력함.(한마디로, 절대 우리가 지정할 일이 없음. 우리가 한다면 null)

(3) NaN
마찬가지로 시스템(컴파일러)가 출력함. Undefined와 달리 정의되지 않은 수학연산
(한마디로, 계산했을 때 오류가 나면 NaN)

## 백틱 
백틱은 여백과 줄바꿈마저 모두 string값으로 나오는 특징이 있음. 
```
 str1 = `
    진달래
        김소월

    나 보기가 역겨워 가실 때에는 
    말없이 고이 보내드리오리다.
 `// 백틱은 이처럼 여백과 줄바꿈 마저도 모두 다 나온다는 특징이 있습니다. 

```

## for문
(1)  When? 관심 있는 변수가 배열일 때 - 모든 원소를 끄집어 오고 싶어.
```배열의 원소를 가져올 때 
for ( i of Array){

}
```
(2) When? 관심 있는 변수가 배열일 때 - 모든 원소를 끄집어 오고 싶어.
```배열의 원소를 가져올 때 
sampleArray.forEach((i)=>{

})
```

## while문
When? 
- 보통 서버를 불러오거나 아주 특수한 경우에만 씀. 




## 배열.  ( 코딩 테스트에서 무지무지하게 많이 나오는 툴 ) 

### 배열을 잘 다뤄서 출력하고 싶을 떄 

배열을 다루는 방법은 딱 3가지라고 생각해. 
```
forEach, map, filter
```

(내가 배열을…) 
(1) 출력하고 싶어! 근데, 각 원소별로 출력할래. => forEach
```
Array.forEach( (x)=>{ console.log(x) } )
```
(2) 출력하고 싶어! 근데, 조작을 해서 배열로 출력할래 ==> map
```
sampleArray.map((x)=> {x + 10}) 
```
(3) 출력하고 싶어! 근데, 그 중 조건에 맞는 아주 일부 원소들만 골라서 배열로 출력할래. ===> filter
```
sampleArray.filter(x => x%2==1) 
```

- sampleArray.map 이건 왜 쓸까요?
(2) 와 (3) 은 반드시 return값으로 배열을 내놓습니다. 
이 때 가장 큰 장점은 원본을 그대로 두고, 복사본을 따로 뿌린다는 것입니다. 
한마디로, 원본이 그대로 보존된다는 것이 장점. 

### 배열의 원소를 직접 조작하고 싶을 때  
(1) sort
When? 정렬(특히, 오름차순 내림차순)
sampleArray.sort( ( a, b ) => { a - b } ) 
```
sampleArray.sort((p1, p2) => p1 - p2);
```
원리
- 기본세팅 : sort는 작은 결과값부터 큰 결과값으로 정렬합니다. (유니코드 순서)
- 조금 더 정밀하게는 콜백함수 내의 리턴값이 양수라면, 순서를 바꾸지 않고, 음수라면 순서를 바꿉니다. 
- 예시에서 리턴값은 (p1 - p2)로 정의되기 때문이지.

근본원리(알고리즘)
- sort의 파라미터는 직관적으로는 버블정렬(최악의 성능인 차례차례 검증)을 할 것 같지만, 꼭 그렇지는 않고, 자바스크립트 내부 엔진이 어떤 정렬을 선택했는지에 따라 다른데, 주로 많이 쓰이는 v8엔진은 Tim sort를 주로 쓴다고 함. (너무 생소한데,  n log n 정렬 알고리즘의 한계를 극복하기 위해서 merge sort를 기반으로 엄청나게 최적화한 것임. 



### 배열에 input 혹은 output으로 원소 넣거나 솎아내고 싶을 떄
(1) push
```
sampleArray.push(  something );
```

(2) 






